# Python для сетевых инженеров 

---

# Ansible

+++
### Ansible

Ansible - это система управления конфигурациями. Ansible позволяет автоматизировать и упростить настройку, обслуживание и развертывание серверов, служб, ПО и др.

Ansible активно развивается в сторону поддержки сетевого оборудования и постоянно появляются новые возможности и модули для работы с сетевым оборудованием.

+++
### Ansible

Примеры задач, которые поможет решить Ansible:
* подключение по SSH к устройствам
 * паралелльное подключение к устройствам по SSH
* отправка команд на устройства
* удобный синтаксис описания устройств:
 * можно разбивать устройства на группы и затем отправлять какие-то команды на всю группу
* поддержка шаблонов конфигураций с Jinja2

+++
### Установка Ansible

Ansible нужно устанавливать только на той машине, с которой будет выполняться управление устройствами.

Требования к управляющему хосту:
* поддержка Python 3 (тестировалось на 3.7)
* Windows не может быть управляющим хостом

Ansible довольно часто обновляется, поэтому лучше установить его в виртуальном окружении.

+++
### Установка Ansible

Установить Ansible можно [по-разному](http://docs.ansible.com/ansible/intro_installation.html#).

```
$ pip install ansible
```

+++
### Параметры оборудования

В примерах раздела используются три маршрутизатора:
* пользователь: cisco
* пароль: cisco
* пароль на режим enable: cisco
* SSH версии 2
* IP-адреса:
 * R1: 192.168.100.1
 * R2: 192.168.100.2
 * R3: 192.168.100.3

---
## Основы Ansible

+++
### Основы Ansible

* Работает без установки агента на управляемые хосты
* Использует SSH для подключения к управляемым хостам
* Выполняет изменения, с помощью модулей Python, которые выполняются на управляемых хостах
* Может выполнять действия локально, на управляющем хосте
* Использует YAML для описания сценариев
* Содержит множество модулей (их количество постоянно растет)
* Легко писать свои модули

+++
### Терминология

* __Control machine__ —  управляющий хост. Сервер Ansible, с которого происходит управление другими хостами
* __Manage node__ —  управляемые хосты
* __Inventory__ —  инвентарный файл. В этом файле описываются хосты, группы хостов. А также могут быть созданы переменные
* __Playbook__ — файл сценариев
* __Play__ —  сценарий (набор задач). Связывает задачи с хостами, для которых эти задачи надо выполнить
* __Task__ —  задача. Вызывает модуль с указанными параметрами и переменными
* __Module__ — модуль Ansible. Реализует определенные функции


+++
### Quick start

Минимум, который нужен для начала работы:
* инвентарный файл - в нем описываются устройства
* изменить конфигурацию Ansible, для работы с сетевым оборудованием
* разобраться с ad-hoc командами - это возможность выполнять простые действия с устройствами из командной строки


---
### Инвентарный файл

+++
### Инвентарный файл

Инвентарный файл - это файл, в котором описываются устройства, к которым Ansible будет подключаться.

В инвентарном файле устройства могут указываться используя IP-адреса или имена.
Устройства могут быть указаны по одному или разбиты на группы.

+++
### Инвентарный файл

Файл описывается в формате INI:
```ini
r5.example.com

[cisco_routers]
192.168.255.1
192.168.255.2
192.168.255.3
192.168.255.4

[cisco_edge_routers]
192.168.255.1
192.168.255.2
```


+++
### Инвентарный файл

По умолчанию, файл находится в ```/etc/ansible/hosts```.

Но можно создавать свой инвентарный файл и использовать его.
Для этого нужно, либо указать его при запуске Ansible, используя опцию ```-i <путь>```, либо указать файл в конфигурационном файле Ansible.


+++
### Инвентарный файл

Если в группу надо добавить несколько устройств с однотипными именами, можно использовать такой вариант записи:

```ini
[cisco_routers]
192.168.255.[1:5]
```

В группу попадут устройства с адресами 192.168.255.1-192.168.255.5.

+++
### Группа из групп

Ansible также позволяет объединять группы устройств в общую группу. Для этого используется специальный синтаксис:
```ini
[cisco_routers]
192.168.255.1
192.168.255.2
192.168.255.3

[cisco_switches]
192.168.254.1
192.168.254.2

[cisco_devices:children]
cisco_routers
cisco_switches
```


---
### Ad Hoc команды

+++
### Ad Hoc команды

Ad-hoc команды - это возможность запустить какое-то действие Ansible из командной строки.

Такой вариант используется, как правило, в тех случаях, когда надо что-то проверить, например, работу модуля.
Или просто выполнить какое-то разовое действие, которое не нужно сохранять.

В любом случае, это простой и быстрый способ начать использовать Ansible.

+++
### Ad Hoc команды

Сначала нужно создать в локальном каталоге инвентарный файл:
```
[cisco_routers]
192.168.100.1
192.168.100.2
192.168.100.3

```

+++
### Ad Hoc команды

Пример ad-hoc команды:
```
$ ansible 192.168.100.1 -i myhosts.ini -c network_cli -e ansible_network_os=ios -u cisco -k -m ios_command -a "commands='sh clock'"
```

+++
### Ad Hoc команды

Результат выполнения будет таким:
```
$ ansible 192.168.100.1 -i myhosts.ini -c network_cli -e ansible_network_os=ios -u cisco -k -m ios_command -a "commands='sh clock'"
```

![ad-hoc](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/1_ad-hoc.png)

+++
### Ad Hoc команды

Часть параметров можно записать в инвентарный файл и тогда их не нужно будет указывать в команде:

```
[cisco_routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco_routers:vars]
ansible_connection=network_cli
ansible_network_os=ios
ansible_user=cisco
ansible_password=cisco
```

Теперь ad-hoc команду можно вызвать так:

```
    $ ansible 192.168.100.1 -i myhosts.ini -m ios_command -a "commands='sh ip int br'"
```

---

### Конфигурационный файл

+++
### Конфигурационный файл

Настройки Ansible можно менять в конфигурационном файле.

Конфигурационный файл Ansible может хранится в разных местах:
* ANSIBLE_CONFIG (переменная окружения)
* ansible.cfg (в текущем каталоге)
* .ansible.cfg (в домашнем каталоге пользователя)
* /etc/ansible/ansible.cfg

Ansible ищет файл конфигурации в указанном порядке и использует первый найденный (конфигурация из разных файлов не совмещается).

+++
### Конфигурационный файл

В конфигурационном файле можно менять множество параметров.
Полный список параметров и их описание, можно найти в [документации](http://docs.ansible.com/ansible/intro_configuration.html).

В текущем каталоге должен быть инвентарный файл myhosts.ini:
```
[cisco_routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco_switches]
192.168.100.100
```

+++
### Конфигурационный файл

Конфигурационный файл ansible.cfg:
```
[defaults]

inventory = ./myhosts.ini
remote_user = cisco
ask_pass = True
```

+++
### Конфигурационный файл

Настройки в конфигурационном файле:
* ```[defaults]``` - секция описывает общие параметры по умолчанию
* ```inventory = ./myhosts.ini``` - местоположение инвентарного файла
* ```remote_user = cisco``` - от имени какого пользователя будет подключаться Ansible
* ```ask_pass = True``` - этот параметр аналогичен опции --ask-pass в командной строке

+++
### Конфигурационный файл

Теперь вызов ad-hoc команды будет выглядеть так:
```
$ ansible cisco_routers -m raw -a "sh ip int br"
```

Теперь не нужно указывать инвентарный файл, пользователя и опцию --ask-pass.


+++
### gathering

По умолчанию, Ansible собирает факты об устройствах.

Факты - это информация о хостах, к которым подключается Ansible.
Эти факты можно использовать в playbook и шаблонах как переменные.

Сбором фактов, по умолчанию, занимается модуль [setup](http://docs.ansible.com/ansible/setup_module.html).

Но, для сетевого оборудования, модуль setup не подходит, поэтому сбор фактов надо отключить.
Это можно сделать в конфигурационном файле Ansible или в playbook.

+++
### gathering

Для сетевого оборудования нужно использовать отдельные модули для сбора фактов (если они есть).

Отключение сбора фактов в конфигурационном файле:
```yml
gathering = explicit
```


+++
### host_key_checking

Параметр host_key_checking отвечает за проверкy ключей, при подключении по SSH.
Если указать в конфигурационном файле ```host_key_checking=False```, проверка будет отключена.

Это полезно, когда с управляющего хоста Ansible надо подключиться к большому количеству устройств первый раз.

Чтобы проверить этот функционал, надо удалить сохраненные ключи для устройств Cisco, к которым уже выполнялось подкление.
В линукс они находятся в файле ~/.ssh/known_hosts.

+++
### host_key_checking

Если выполнить ad-hoc команду, после удаления ключей, вывод будет таким:
```
$ ansible cisco_routers -m raw -a "sh ip int br"
```

![host_key_checking](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/host_key_checking.png)


+++
### host_key_checking

Добавляем в конфигурационный файл параметр host_key_checking:
```
[defaults]

inventory = ./myhosts.ini

remote_user = cisco
ask_pass = True

host_key_checking=False
```

+++
### host_key_checking

И повторим ad-hoc команду:
```
$ ansible cisco_routers -m raw -a "sh ip int br"
```

+++
Результат выполнения команды:

![host_key_checking2](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/host_key_checking2.png)

+++
### host_key_checking

Обратите внимание на строки:
```
 Warning: Permanently added '192.168.100.1' (RSA) to the list of known hosts.
```

Ansible сам добавил ключи устройств в файл ~/.ssh/known_hosts.
При подключении в следующий раз этого сообщения уже не будет.


Другие параметры конфигурационного файла можно посмотреть в документации.
Пример конфигурационного файла в [репозитории Ansible](https://github.com/ansible/ansible/blob/devel/examples/ansible.cfg).

---

### Модули Ansible

+++
### Модули Ansible

Вместе с установкой Ansible устанавливается также большое количество модулей (библиотека модулей).
В текущей библиотеке модулей, находится порядка 200 модулей.

Модули отвечают за действия, которые выполняет Ansible.
При этом, каждый модуль, как правило, отвечает за свою конкретную и небольшую задачу.

Модули можно выполнять отдельно, в ad-hoc командах или собирать в определенный сценарий (play), а затем в playbook.

+++
### Модули Ansible

Как правило, при вызове модуля, ему нужно передать аргументы.
Какие-то аргументы будут управлять поведением и параметрами модуля, а какие-то передавать, например, команду, которую надо выполнить.

Например, мы уже выполняли ad-hoc команды, используя модуль raw. И передавали ему аргументы:
```
$ ansible cisco_routers -i myhosts.ini -m raw -a "sh ip int br" -u cisco --ask-pass
```

+++
### Модули Ansible

Выполнение такой же задачи в playbook будет выглядеть так:
```
    - name: run sh ip int br        
      raw: sh ip int br | ex unass
```

После выполнения, модуль возвращает результаты выполнения в формате JSON.

+++
### Модули Ansible

Модули Ansible, как правило, идемпотентны.
Это означает, что модуль можно выполнять сколько угодно раз, но при этом модуль будет выполнять изменения, только если система не находится в желаемом состоянии.

+++
### Модули Ansible

В Ansible модули разделены на две категории:
* __core__ - это модули, которые всегда устанавливаются вместе с Anible. Их поддерживает основная команда разработчиков Ansible.
* __extra__ - это модули на данный момент устанавливаются с Ansible, но нет гарантии, что они и дальше будут устанавливаться с Ansible. Возможно, в будущем, их нужно будет устанавливать отдельно. Большинство этих модулей поддерживаются сообществом.

Также в Ansible модули разделены по функциональности.
Список всех категорий находится в [документации](http://docs.ansible.com/ansible/modules_by_category.html).


---
## Основы playbooks

+++
### Основы playbooks

Playbook (файл сценариев) — это файл в котором описываются действия, которые нужно выполнить на какой-то группе хостов.

Внутри playbook:
* play - это набор задач, которые нужно выполнить для группы хостов
* task - это конкретная задача. В задаче есть, как минимум:
 * описание (название задачи можно не писать, но очень рекомендуется)
 * модуль и команда (действие в модуле)


+++
### Синтаксис playbook

Пример plabook 1_show_commands_with_raw.yml:
```
- name: Run show commands on routers
  hosts: cisco_routers
  gather_facts: false

  tasks:

    - name: run sh ip int br        
      raw: sh ip int br | ex unass

    - name: run sh ip route
      raw: sh ip route

- name: Run show commands on switches
  hosts: cisco_switches
  gather_facts: false

  tasks:

    - name: run sh int status
      raw: sh int status

    - name: run sh vlan
      raw: show vlan
```

+++

И тот же playbook с отображением элементов:

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook.png)

+++
### Синтаксис playbook

Так выглядит выполнение playbook:
```
$ ansible-playbook 1_show_commands_with_raw.yml
```

+++
Так выглядит выполнение playbook:

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook_execution.png)

+++
### Синтаксис playbook

Запуск playbook с опцией -v (вывод сокращен):
```
$ ansible-playbook 1_show_commands_with_raw.yml -v
```

![Verbose playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook-verbose.png)


+++
### Порядок выполнения задач и сценариев

Сценарии (play) и задачи (task) выполняются последовательно, в том порядке, в котором они описаны в playbook.

Если в сценарии, например, две задачи, то сначала первая задача должна быть выполнена для всех устройств, которые указаны в параметре hosts.
Только после того, как первая задача была выполнена для всех хостов, начинается выполнение второй задачи.

Если в ходе выполнения playbook, возникла ошибка в задаче на каком-то устройстве, это устройство исключается, и другие задачи на нем выполняться не будут.

+++
### Порядок выполнения задач и сценариев

Например, заменим пароль пользователя cisco на cisco123 (правильный cisco) на маршрутизаторе 192.168.100.1, и запустим playbook заново:
```
$ ansible-playbook 1_show_commands_with_raw.yml
```

+++

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook_failed_execution.png)

+++
### Порядок выполнения задач и сценариев

Обратите внимание на ошибку в выполнении первой задачи для маршрутизатора 192.168.100.1.

Во второй задаче 'TASK [run sh ip route]', Ansible уже исключил маршрутизатор и выполняет задачу только для маршрутизаторов 192.168.100.2 и 192.168.100.3.

+++
### Порядок выполнения задач и сценариев

Еще один важный аспект - Ansible выдал сообщение:
```
to retry, use: --limit @/home/nata/pyneng_course/chapter15/1_show_commands_with_raw.retry
```
+++
### Порядок выполнения задач и сценариев

Если, при выполнении playbook, на каком-то устройстве возникла ошибка, Ansible создает специальный файл, который называется точно так же как playbook, но расширение меняется на retry.

В этом файле хранится имя или адрес устройства на котором возникла ошибка (файл 1_show_commands_with_raw.retry):
```
192.168.100.1
```

+++
### Порядок выполнения задач и сценариев

После настройки правильного пароля на маршрутизаторе, перезапускаем playbook:
```
$ ansible-playbook 1_show_commands_with_raw.yml --limit @/home/nata/pyneng_course/chapter15/1_show_commands_with_raw.retry
```

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook-retry.png)

+++
### Порядок выполнения задач и сценариев

Ansible взял список устройств, которые перечислены в файле retry и выполнил playbook только для них.

Можно запустить playbook и так:
```
$ ansible-playbook 1_show_commands_with_raw.yml --limit @1_show_commands_with_raw.retry
```

+++
### Параметр --limit

Параметр --limit позволяет ограничивать, для каких хостов или групп будет выполняться playbook, при этом, не меняя сам playbook.

Например, таким образом playbook можно запустить только для маршрутизатора 192.168.100.1:
```
$ ansible-playbook 1_show_commands_with_raw.yml --limit 192.168.100.1
```

+++

### Идемпотентность

Модули Ansible идемпотентны.
Это означает, что модуль можно выполнять сколько угодно раз, но при этом модуль будет выполнять изменения, только если система не находится в желаемом состоянии.

Но, есть исключения из такого поведения.
Например, модуль raw всегда вносит изменения.
Поэтому в выполнении playbook выше, всегда отображалось состояние changed.

+++
### Идемпотентность

Например, если в задаче указано, что на сервер Linux надо установить пакет httpd, то он будет установлен только в том случае, если его нет.
То есть, действие не будет повторяться снова и снова, при каждом запуске.
А лишь тогда, когда пакета нет.

Аналогично, и с сетевым оборудованием.
Если задача модуля выполнить команду в конфигурационном режиме, а она уже есть на устройстве, модуль не будет вносить изменения.


---
### Переменные

+++
### Переменные

Переменной может быть:
* информация об устройстве, которая собрана как факт, а затем используется в шаблоне
* в переменные можно записывать полученный вывод команды
* переменная может быть указана вручную в playbook

+++
### Имена переменных

В Ansible есть определенные ограничения по формату имен переменных:
* Переменные могут состоять из букв, чисел и символа ```_```
* Переменные должны начинаться с буквы

+++
### Имена переменных

Кроме того, можно создавать словари с переменными (в формате YAML):
```
R1:
  IP: 10.1.1.1/24
  DG: 10.1.1.100
```

+++
### Имена переменных

Обращаться к переменным в словаре можно двумя вариантами:
```
R1['IP']
R1.IP
```

При использовании второго варианта, могут быть проблемы, если название ключа совпадает с зарезервированным словом (методом или атрибутом) в Python или Ansible.

+++
### Где можно определять переменные

Переменные можно создавать:
* в инвентарном файле
* в playbook
* в специальных файлах для группы/устройства
* в отдельных файлах, которые добавляются в playbook через include (как в Jinja2)
* в ролях, которые затем используются
* можно передавать переменные при вызове playbook

Также можно использовать факты, которые были собраны про устройство, как переменные.


+++
### Переменные в инвентарном файле

В инвентарном файле можно указывать переменные для группы:
```
[cisco_routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco_switches]
192.168.100.100

[cisco_routers:vars]
ntp_server=192.168.255.100
log_server=10.255.100.1
```

+++
### Переменные в playbook

Переменные можно задавать прямо в playbook

```
- name: Run show commands on routers
  hosts: cisco_routers
  gather_facts: false

  vars:
    ntp_server: 192.168.255.100
    log_server: 10.255.100.1

  tasks:

    - name: run sh ip int br        
      raw: sh ip int br | ex unass

    - name: run sh ip route
      raw: sh ip route

```

+++
### Переменные в специальных файлах

Ansible позволяет хранить переменные для группы/устройства в специальных файлах:
* Для групп устройств, переменные должны находится в каталоге group_vars, в файлах, которые называются, как имя группы.
 * в каталоге group_vars можно создавать файл all, в котором будут находиться переменные, которые относятся ко всем группам.
* Для конкретных устройств, переменные должны находится в каталоге host_vars, в файлах, которые соответствуют имени или адресу хоста.

+++
### Переменные в специальных файлах

Ansible позволяет хранить переменные для группы/устройства в специальных файлах:
* Все файлы с переменными, должны быть в формате YAML. Расширение файла может быть yml, yaml, json или без расширения
* каталоги group_vars и host_vars должны находиться в том же каталоге, что и playbook. Или могут находиться внутри каталога inventory (первый вариант более распространенный).
 * если каталоги и файлы названы правильно и расположены в указанных каталогах, Ansible сам разпознает файлы и будет использовать переменные

+++
### Переменные в специальных файлах

Например, если инвентарный файл myhosts.ini выглядит так:
```
[cisco_routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco_switches]
192.168.100.100
```

+++
### Переменные в специальных файлах

Можно создать такую структуру каталогов:
```
├── group_vars                 _
│   ├── all.yml                 |
│   ├── cisco_routers.yml       |  Каталог с переменными для групп устройств
│   └── cisco_switches.yml     _|
|
├── host_vars                  _
│   ├── 192.168.100.1           |
│   ├── 192.168.100.2           |
│   ├── 192.168.100.3           |  Каталог с переменными для устройств 
│   └── 192.168.100.100        _|
|
└── myhosts.ini                 |  Инвентарный файл
```

+++
### Переменные в специальных файлах

Файл group_vars/all.yml:
```
ansible_connection: network_cli
ansible_network_os: ios
ansible_user: cisco
ansible_password: cisco
ansible_become: yes
ansible_become_method: enable
ansible_become_pass: cisco

```

+++
### Переменные в специальных файлах

group_vars/cisco_routers.yml
```
log_server: 10.255.100.1
ntp_server: 10.255.100.1
users:
  user1: pass1
  user2: pass2
  user3: pass3
```

+++
### Переменные в специальных файлах

group_vars/cisco_switches.yml
```
vlans:
  - 10
  - 20
  - 30
```

+++
### Переменные в специальных файлах

Файлы с переменными для хостов однотипны и в них меняются только адреса и имена.

Файл host_vars/192.168.100.1
```
hostname: london_r1
mgmnt_loopback: 100
mgmnt_ip: 10.0.0.1
ospf_ints:
  - 192.168.100.1
  - 10.0.0.1
  - 10.255.1.1
```

+++
### Приоритетность переменных

Чаще всего, переменная с определенным именем только одна.

Но, иногда может понадобиться создать переменную в разных местах и тогда нужно понимать, в каком порядке Ansible перезаписывает переменные.

+++
### Приоритетность переменных

Приоритет переменных (последние значения переписывают предыдущие):
* Значения переменных в ролях
 * задачи в ролях будут видеть собственные значения. Задачи, которые определены вне роли, будут видеть последние значения переменных роли
* переменные в инвентарном файле
* переменные для группы хостов в инвентарном файле
* переменные для хостов в инвентарном файле

+++
### Приоритетность переменных

* переменные в каталоге group_vars
* переменные в каталоге host_vars
* факты хоста
* переменные сценария (play)
* переменные сценария, которые запрашиваются через vars_prompt

+++
### Приоритетность переменных

* переменные, которые передаются в сценарий через vars_files
* переменные полученные через параметр register
* set_facts
* переменные из роли и помещенные через include
* переменные блока (переписывают другие значения только для блока)
* переменные задачи (task) (переписывают другие значения только для задачи)
* переменные, которые передаются при вызове playbook через параметр --extra-vars (всегда наиболее приоритетные)

---
### Работа с результатами выполнения модуля

+++
### verbose

Флаг verbose позволяет подробно посмотреть какие шаги выполняет Ansible.

Пример запуска playbook с флагом verbose (вывод сокращен):
```
ansible-playbook 1_show_commands_with_raw.yml -v
```

![Verbose playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook-verbose.png)

+++
### verbose

При увеличении количества букв v в флаге, вывод становится более подробным.
```
ansible-playbook 1_show_commands_with_raw.yml -vvv
```

+++
### verbose

В выводе видны результаты выполнения задачи, они возвращаются в формате JSON:
* __changed__ - ключ, который указывает были ли внесены изменения
* __rc__ - return code. Это поле появляется в выводе тех модулей, которые выполняют какие-то команды
* __stderr__ - ошибки, при выполнении команды. Это поле появляется в выводе тех модулей, которые выполняют какие-то команды
* __stdout__ - вывод команды
* __stdout_lines__ - вывод в виде списка команд, разбитых построчно


+++
### register

Параметр __register__ сохраняет результат выполнения модуля в переменную.
Затем эта переменная может использоваться в шаблонах, в принятии решений о ходе сценария или для отображении вывода.

+++
### register

В playbook 2_register_vars.yml, с помощью register, вывод команды sh ip int br сохранен в переменную sh_ip_int_br_result:
```
- name: Run show commands on routers
  hosts: cisco_routers
  gather_facts: false

  tasks:

    - name: run sh ip int br
      raw: sh ip int br | ex unass
      register: sh_ip_int_br_result
```

+++
### register

Если запустить этот playbook, вывод не будет отличаться, так как вывод только записан в переменную, но с переменной не выполяется никаких действий.
Следующий шаг - отобразить результат выполнения команды, с помощью модуля debug.


+++
### debug

Модуль debug позволяет отображать информацию на стандартный поток вывода.
Это может быть произвольная строка, переменная, факты об устройстве.

+++
### debug

Для отображения сохраненных результатов выполнения команды, в playbook 2_register_vars.yml добавлена задача с модулем debug:
```
- name: Run show commands on routers
  hosts: cisco_routers
  gather_facts: false

  tasks:

    - name: run sh ip int br
      raw: sh ip int br | ex unass
      register: sh_ip_int_br_result

    - name: Debug registered var
      debug: var=sh_ip_int_br_result.stdout_lines
```

+++
### debug

Обратите внимание, что выводится не всё содержимое переменной sh_ip_int_br_result, а только содержимое stdout_lines.
В sh_ip_int_br_result.stdout_lines находится список строк, поэтому вывод будут структурированн.

Результат запуска playbook будет выглядит так:
```
$ ansible-playbook 2_register_vars.yml
```

+++
### debug

![Verbose playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/2_register_vars.png)


+++
### register, debug, when

С помощью ключевого слова __when__, можно указать условие, при выполнении которого, задача выполняется.
Если условие не выполняется, то задача пропускается.

when в Ansible используется как if в Python.


+++
### register, debug, when

Пример playbook 3_register_debug_when.yml:
```
- name: Run show commands on routers
  hosts: cisco_routers
  gather_facts: false

  tasks:

    - name: run sh ip int br
      raw: sh ip int bri | ex unass
      register: sh_ip_int_br_result

    - name: Debug registered var
      debug:
        msg: "Error in command"
      when: "'invalid' in sh_ip_int_br_result.stdout"
```

+++
### register, debug, when

Модуль debug отображает не содержимое сохраненной переменной, а сообщение, которое указано в переменной msg.

Задача будет выполнена только в том случае, если в выводе sh_ip_int_br_result.stdout будет найдена строка invalid
```
when: "'invalid' in sh_ip_int_br_result.stdout"
```

Модули, которые работают с сетевым оборудованием, автоматически проверяют ошибки, при выполнении команд. Тут этот пример используется для демонстрации возможностей Ansible.

+++
### register, debug, when

Выполнение playbook:
```
$ ansible-playbook 3_register_debug_when.yml
```

![Verbose playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/3_register_debug_when_skip.png)

+++
### register, debug, when

Выполнение того же playbook, но с ошибкой в команде:
```
- name: Run show commands on routers
  hosts: cisco_routers
  gather_facts: false

  tasks:

    - name: run sh ip int br
      raw: shh ip int bri | ex unass
      register: sh_ip_int_br_result

    - name: Debug registered var
      debug:
        msg: "Error in command"
      when: "'invalid' in sh_ip_int_br_result.stdout"
```

+++
### register, debug, when

Теперь результат выполнения такой:
```
$ ansible-playbook 3_register_debug_when.yml
```

![Verbose playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/3_register_debug_when.png)
